#!/usr/bin/python

# ===================== begin_copyright_notice ============================
#
# Copyright (C) 2023-2024 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# ===================== end_copyright_notice ==============================

from generator_vulkan import (
    get_functions,
    get_structs,
    get_enums,
    FuncType,
    FuncLevel,
    Token,
    Argument,
    ReturnValue,
    VkStruct,
    Field,
    VkEnum,
    Enumerator,
)

from datetime import datetime
from pathlib import Path
from typing import TypeVar
import copy
import platform
import re
import shutil
import textwrap

import mako.template
import mako.exceptions



Versioned = TypeVar('Versioned', Token, VkStruct)  # Enums aren't versioned.


AUTO_GENERATED_HEADER = f"""
//
// FILE AUTO-GENERATED BY THE GITS CODE GENERATOR. DO NOT MODIFY DIRECTLY.
// GENERATED ON: {datetime.now()}
//
""".strip('\n')

egl_function_names = '''
	eglGetError
	(...)
	eglWaitSyncANDROID
'''.strip('\r\n')

wgl_function_names = '''
	wglCopyContext
	(...)
	wglCopyImageSubDataNV
'''.strip('\r\n')


def version_suffix(version: int) -> str:
    """Return a version suffix (like '_V1'), empty for version 0."""
    if version <= 0:
        return ''
    else:
        return f'_V{version}'

def make_id(name: str, version: int) -> str:
    """Return an ID (like 'ID_GL_BEGIN_V1')."""
    id_ = re.sub('([a-z])([A-Z])', r'\g<1>_\g<2>', name)
    id_ = re.sub('([0-9])D', r'_\g<1>D_', id_)
    id_ = id_.rstrip('_').upper()

    return f'ID_{id_}{version_suffix(version)}'

def make_cname(name: str, version: int) -> str:
    """Return a Cname (like 'CglBegin_V1')."""
    return f'C{name}{version_suffix(version)}'

def make_ctype(type_name: str, wrap_type: str = '') -> str:
    """Return a Ctype (like 'Cfloat::CSArray')."""
    if wrap_type:  # Wrap types override deduced Ctypes.
        return wrap_type

    type_name = type_name.replace('const ', '')

    if type_name in vulkan_uint32:
        return 'Cuint32_t'
    elif type_name in vulkan_uint64:
        return 'Cuint64_t'

    if '*' in type_name:
        type_name = type_name.strip(' *')
        if type_name in vulkan_structs:
            return f'C{type_name}'
        else:
            return f'C{type_name}::CSArray'

    return f'C{type_name}'

def make_func_type_flags(func_type: FuncType) -> str:
    """Convert FuncType into GITS' C++ representation string."""
    return ' | '.join(f'GITS_VULKAN_{flag.name}_APITYPE' for flag in func_type)

def get_indent(s: str) -> str:
    """Return the base indentation of given code as a string."""
    # In case of multiline strings, first line should be the least indented.
    match = re.match(r'\s*', s)
    if match is None:
        return ''
    else:
        return match.group()

def wrap_in_if(condition: str, code: str, indent: str = '  ') -> str:
    """Wrap a multiline string in a C++ if statement."""

    orig_indent = get_indent(code)

    # So we don't double orig_indent when indenting everything at the end.
    # Dedent doesn't accept amount, but it should dedent exactly by orig_indent.
    dedented_code = textwrap.dedent(code)

    # Indent by one level.
    indented_code = textwrap.indent(dedented_code, indent)

    if_statement = f'if ({condition}) {{\n{indented_code}\n}}'

    # Indent everything by original indent amount.
    return textwrap.indent(if_statement, orig_indent)

def split_functions_by_level(
    vk_functions: list[Token],
) -> dict[FuncLevel, list[Token]]:
    """
    Separate Vulkan functions (tokens) by their level.

    Parameters:
        vk_functions: List of Vulkan functions of various levels.

    Returns:
        A dict, mapping levels to lists of functions of each level.
    """
    functions_by_level: dict[FuncLevel, list[Token]] = {}
    functions_by_level[FuncLevel.PROTOTYPE] = []
    functions_by_level[FuncLevel.GLOBAL] = []
    functions_by_level[FuncLevel.INSTANCE] = []
    functions_by_level[FuncLevel.DEVICE] = []

    for token in vk_functions:
        functions_by_level[token.level].append(token)

    return functions_by_level

def without_older_versions(input: list[Versioned]) -> list[Versioned]:
    """
    Filter out older versions of Vulkan tokens or structs from a list.

    Parameters:
        input: List of tokens or structs.

    Returns:
        A list containing only newest versions of items from input.
    """
    newest_token_versions: dict[str, Versioned] = {}

    for item in input:
        newest_so_far: Versioned | None = newest_token_versions.get(item.name)
        if newest_so_far is None or newest_so_far.version < item.version:
            newest_token_versions[item.name] = item

    return list(newest_token_versions.values())

def split_arrays_from_name(name_with_array: str) -> tuple[str, str]:
    """
    Separate array declarations from variable or type name.

    Parameters:
        name_with_array: Name that may contain array declarations.

    Returns:
        Tuple of (name, array). Examples:

        'baseAndCount [2]' -> ('baseAndCount', '[2]')
        'matrix[3][4]' -> ('matrix', '[3][4]')
    """
    array_regex: str = r'\[[0-9_]+\]'
    matches = re.findall(array_regex, name_with_array)
    if matches:
        name: str = re.sub(array_regex, '', name_with_array)
        arrays: str = ''.join(matches)
    else:
        name: str = name_with_array
        arrays: str = ''

    return (name.strip(), arrays.strip())

def args_to_str(
    args: list[Argument],
    format_string: str,
    rstrip_string: str = '',
) -> str:
    """
    Format Vulkan function call arguments as string.

    Each argument will get square brackets and their contents removed, then
    `format_string.format(...)` will be run on it. The results will all get
    concatenated and returned.

    Placeholder strings supported for formatting are:
        name: Name with array part removed.
        type: Type with array part removed.
        array: Array declaration (or empty string) extracted from name or type.
        wrap_params: wrap_params from generator (if present) or name (described above).
        ctype: Name of the class wrapping this argument, e.g. `CVkDevice`.

    Parameters:
        args: Parameters of the Vulkan function.
        format_string: Format of one argument, with placeholders like '{name}'.
        rstrip_string: String to rstrip the result with; defaults to ''.

    Returns:
        A C++ arguments string. Examples:

            'int foo, float bar[2], bool baz'
            '*_foo, *_bar, *_baz'
    """

    args_str = ''

    arg: Argument
    for arg in args:
        # Argument name or type can contain an array declaration, like 'baseAndCount[2]'
        # in OpenGL or 'VkFragmentShadingRateCombinerOpKHR[2]' in Vulkan.
        name: str
        name_array: str
        type: str
        type_array: str
        name, name_array = split_arrays_from_name(arg.name)
        type, type_array = split_arrays_from_name(arg.type)
        assert not (name_array and type_array), (
            "Argument name and type can't both have array declarations.")
        array: str = name_array or type_array

        wrap_type: str = arg.wrap_type or ''
        wrap_params: str = arg.wrap_params or name
        ctype: str = make_ctype(type, wrap_type)

        args_str += format_string.format(
            name=name,
            type=type,
            array=array,
            wrap_params=wrap_params,
            ctype=ctype,
        )

    return args_str.rstrip(rstrip_string)

def arg_call(
    token: Token,
    *,  # Force keyword args, as calls with positional bools are cryptic.
    add_retval: bool,
    recording: bool = False,
    wrap: bool = False,
) -> str:
    """Return arguments formatted for a call, like '(return_value, a, b)'."""
    args_str = ''

    if add_retval and token.return_value.type != 'void':
        args_str += 'return_value, '

    args_str += args_to_str(token.args, '{name}, ')

    if recording:
        args_str += 'Recording(_recorder), '

    if wrap:
        args_str += '_recorder, '

    return f"({args_str.strip(', ')})"

def driver_definition(token: Token) -> str:
    """Return a Token's C++ definition for the driver file."""
    ret_type: str = token.return_value.type
    if ret_type == 'void':
        ret_type = 'void_t'

    custom = 'CUSTOM_' if token.custom_driver else ''

    first_argument_name = ''
    if token.level in (FuncLevel.INSTANCE, FuncLevel.DEVICE):
        first_argument_name = f', {token.args[0].name}'

    params: str = args_to_str(token.args, '{type} {name}{array}, ', ', ')
    args: str = arg_call(token, add_retval=False)

    macro_name = f'VK_{custom}{token.level.name}_LEVEL_FUNCTION'
    macro_args = f'({ret_type}, {token.name}, ({params}), {args}{first_argument_name})'

    return macro_name + macro_args

def driver_call(token: Token) -> str:
    """
    Create a string containing a driver call (for gitsPluginPrePostAuto.cpp).

    Parameters:
        token: data for one version of a token

    Returns:
        A C++ driver call string. Examples:

        'wrapper.Drivers().gl.glAccum(op, value);'
        'execWrap_glGetIntegerv(pname, data);'
        'auto return_value = wrapper.Drivers().gl.glMapBuffer(target, access);'
    """

    has_retval: bool = token.return_value.type != 'void'
    retval_assignment = 'auto return_value = ' if has_retval else ''

    exec_wrap: bool = token.interceptor_exec_override is True
    function_prefix = 'execWrap_' if exec_wrap else 'wrapper.Drivers().gl.'

    driver_args: str = arg_call(token, add_retval=False)

    return f'{retval_assignment}{function_prefix}{token.name}{driver_args};'

def mako_write(inpath: str | Path, outpath: str | Path, **kwargs) -> int:
    """Render a Mako template into a file."""
    # Objects used by all (or almost all) Mako templates.
    common_objects = {
        'FuncType': FuncType,
        'FuncLevel': FuncLevel,
        'Token': Token,
        'Argument': Argument,
        'ReturnValue': ReturnValue,
        'VkStruct': VkStruct,
        'Field': Field,
        'VkEnum': VkEnum,
        'Enumerator': Enumerator,
        'AUTO_GENERATED_HEADER': AUTO_GENERATED_HEADER,
    }

    inpath = Path(inpath)
    outpath = Path(outpath)

    try:
        print(f"Generating {outpath}...")
        template = mako.template.Template(filename=str(inpath))
        rendered = template.render(**(common_objects | kwargs))
        rendered = re.sub(r'\r\n', r'\n', rendered)

        destination = Path('..') / outpath
        with destination.open(mode='w') as fout:
            fout.write(rendered)
    except Exception:
        traceback = mako.exceptions.RichTraceback()
        for filename, lineno, function, line in traceback.traceback:
            print(f"{filename}({lineno}) : error in {function}")
            print(line, "\n")
        print(f"{traceback.error.__class__.__name__}: {traceback.error}")
        return -1
    return 0

def update_gl_ids(
    source: str | Path,
    destination_subpath: str | Path,
    gl_functions: dict[str, list[Token]]
) -> None:
    """
    Append new IDs (if any) to an ID file.

    Parameters:
        source: Path to the Mako template file.
        destination_subpath: Path to copy the file to; relative to `OpenGL/`.
        gl_functions: Dict of Tokens to generate IDs from.
    """
    source = Path(source)
    destination_subpath = Path(destination_subpath)

    gl_ids: set[str] = set()
    with source.open(mode='r') as gl_ids_file:
        for line in gl_ids_file:
            if line.startswith('ID'):
                gl_id = line.strip(',\n')
                gl_ids.add(gl_id)

    new_ids = ''
    for token_versions in gl_functions.values():
        for token in token_versions:
            gl_id = make_id(token.name, token.version)
            if gl_id not in gl_ids:
                new_ids += gl_id + ',\n'

    if not new_ids:
        print(f"File {source} is up to date.")
    else:
        print(f"Adding new IDs to {source} ...")
        with source.open(mode='a') as gl_ids_file:
            gl_ids_file.write(new_ids)

    destination = Path('..') / destination_subpath
    print(f"Copying {source} to {destination_subpath} ...")
    shutil.copy2(source, destination)


def main() -> None:
    """Generate all the files."""
    all_tokens: list[Token] = get_functions()
    enabled_tokens: list[Token] = [f for f in all_tokens if f.enabled]
    newest_tokens: list[Token] = without_older_versions(all_tokens)

    # update_gl_ids('glIDs.h', 'common/include', gl_functions=enabled_tokens)

    vulkan_layer_bin_path: str = ''
    match platform.system():
        case 'Windows':
            vulkan_layer_bin_path = '.\\\\VkLayer_vulkan_GITS_recorder.dll'
        case 'Linux':
            vulkan_layer_bin_path = './libVkLayer_vulkan_GITS_recorder.so'
        case other_system:
            raise NotImplementedError(
                f"Path to Vulkan layer dynamic library is unknown for system '{other_system}'.")
    mako_write(
        'templates/VkLayer_vulkan_GITS_recorder.json.mako',
        'layer/VkLayer_vulkan_GITS_recorder.json',
        vulkan_layer_bin_path=vulkan_layer_bin_path,
    )

    mako_write(
        'templates/vkX.def.mako',
        'layer/vkLayer.def',
        library_name='VkLayer_vulkan_GITS_recorder.dll',
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vkX.def.mako',
        'interceptor/vkPlugin.def',
        library_name='vulkan-1.dll',
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vulkanDriversAuto.inl.mako',
        'common/include/vulkanDriversAuto.inl',
        args_to_str=args_to_str,
        arg_call=arg_call,
        driver_definition=driver_definition,
        functions_by_level=split_functions_by_level(newest_tokens),
    )

if __name__ == '__main__':
    main()
