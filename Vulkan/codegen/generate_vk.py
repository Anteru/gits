#!/usr/bin/python

# ===================== begin_copyright_notice ============================
#
# Copyright (C) 2023-2024 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# ===================== end_copyright_notice ==============================

from generator_vulkan import (
    get_functions,
    get_structs,
    get_enums,
    FuncType,
    FuncLevel,
    Token,
    Argument,
    ReturnValue,
    VkStruct,
    Field,
    VkEnum,
    Enumerator,
)

from datetime import datetime
from pathlib import Path
import copy
import platform
import re
import shutil
import textwrap

import mako.template
import mako.exceptions


AUTO_GENERATED_HEADER = f"""
//
// FILE AUTO-GENERATED BY THE GITS CODE GENERATOR. DO NOT MODIFY DIRECTLY.
// GENERATED ON: {datetime.now()}
//
""".strip('\n')

egl_function_names = '''
	eglGetError
	(...)
	eglWaitSyncANDROID
'''.strip('\r\n')

wgl_function_names = '''
	wglCopyContext
	(...)
	wglCopyImageSubDataNV
'''.strip('\r\n')


def version_suffix(version: int) -> str:
    """Return a version suffix (like '_V1'), empty for version 0."""
    if version <= 0:
        return ''
    else:
        return f'_V{version}'

def make_id(name: str, version: int) -> str:
    """Return an ID (like 'ID_GL_BEGIN_V1')."""
    id_ = re.sub('([a-z])([A-Z])', r'\g<1>_\g<2>', name)
    id_ = re.sub('([0-9])D', r'_\g<1>D_', id_)
    id_ = id_.rstrip('_').upper()

    return f'ID_{id_}{version_suffix(version)}'

def make_cname(name: str, version: int) -> str:
    """Return a Cname (like 'CglBegin_V1')."""
    return f'C{name}{version_suffix(version)}'

def make_ctype(type_name: str, wrap_type: str = '') -> str:
    """Return a Ctype (like 'Cfloat::CSArray')."""
    if wrap_type:  # Wrap types override deduced Ctypes.
        return wrap_type

    type_name = type_name.replace('const ', '')

    if type_name in vulkan_uint32:
        return 'Cuint32_t'
    elif type_name in vulkan_uint64:
        return 'Cuint64_t'

    if '*' in type_name:
        type_name = type_name.strip(' *')
        if type_name in vulkan_structs:
            return f'C{type_name}'
        else:
            return f'C{type_name}::CSArray'

    return f'C{type_name}'

def make_func_type_flags(func_type: FuncType) -> str:
    """Convert FuncType into GITS' C++ representation string."""
    return ' | '.join(f'GITS_VULKAN_{flag.name}_APITYPE' for flag in func_type)

def get_indent(s: str) -> str:
    """Return the base indentation of given code as a string."""
    # In case of multiline strings, first line should be the least indented.
    match = re.match(r'\s*', s)
    if match is None:
        return ''
    else:
        return match.group()

def wrap_in_if(condition: str, code: str, indent: str = '  ') -> str:
    """Wrap a multiline string in a C++ if statement."""

    orig_indent = get_indent(code)

    # So we don't double orig_indent when indenting everything at the end.
    # Dedent doesn't accept amount, but it should dedent exactly by orig_indent.
    dedented_code = textwrap.dedent(code)

    # Indent by one level.
    indented_code = textwrap.indent(dedented_code, indent)

    if_statement = f'if ({condition}) {{\n{indented_code}\n}}'

    # Indent everything by original indent amount.
    return textwrap.indent(if_statement, orig_indent)

def args_to_str(
    args: list[Argument],
    format_string: str,
    rstrip_string: str = '',
) -> str:
    """
    Format Vulkan function call arguments as string.

    Each argument will get square brackets and their contents removed, then
    `format_string.format(...)` will be run on it. The results will all get
    concatenated and returned.

    Placeholder strings supported for formatting are:
        name_with_array: Unedited name straight from generator, e.g. `baseAndCount [2]`.
        name: Name with the array part removed.
        type: Type straight from generator.
        wrap_params: wrap_params from generator (if present) or name (described above).
        ctype: Name of the class wrapping this argument, e.g. `CVkDevice`.

    Parameters:
        args: Parameters of the Vulkan function.
        format_string: Format of one arg with {} in place of arg name.
        rstrip_string: String to rstrip the result with; defaults to ''.

    Returns:
        A C++ arguments string. Examples:

            'foo, bar, baz'
            '*_foo, *_bar, *_baz'
    """

    args_str = ''

    arg: Argument
    for arg in args:
        name_with_array: str = arg.name
        # Some arguments are arrays; remove square brackets from their names.
        # For example, `baseAndCount[2]` -> `baseAndCount`.
        name: str = re.sub(r'\[.+?\]', '', name_with_array).strip()
        type: str = arg.type
        wrap_type: str = arg.wrap_type or ''
        wrap_params: str = arg.wrap_params or name
        ctype: str = make_ctype(type, wrap_type)

        args_str += format_string.format(
            name_with_array=name_with_array,
            name=name,
            type=type,
            wrap_params=wrap_params,
            ctype=ctype,
        )

    return args_str.rstrip(rstrip_string)

def arg_call(
    token: Token,
    *,  # Force keyword args, as calls with positional bools are cryptic.
    add_retval: bool,
    recording: bool = False,
    wrap: bool = False,
) -> str:
    """Return arguments formatted for a call, like '(return_value, a, b)'."""
    args_str = ''

    if add_retval and token.return_value.type != 'void':
        args_str += 'return_value, '

    args_str += args_to_str(token.args, '{name}, ')

    if recording:
        args_str += 'Recording(_recorder), '

    if wrap:
        args_str += '_recorder, '

    return f"({args_str.strip(', ')})"

def driver_call(token: Token) -> str:
    """
    Create a string containing a driver call (for gitsPluginPrePostAuto.cpp).

    Parameters:
        token: data for one version of a token

    Returns:
        A C++ driver call string. Examples:

        'wrapper.Drivers().gl.glAccum(op, value);'
        'execWrap_glGetIntegerv(pname, data);'
        'auto return_value = wrapper.Drivers().gl.glMapBuffer(target, access);'
    """

    has_retval: bool = token.return_value.type != 'void'
    retval_assignment = 'auto return_value = ' if has_retval else ''

    exec_wrap: bool = token.interceptor_exec_override is True
    function_prefix = 'execWrap_' if exec_wrap else 'wrapper.Drivers().gl.'

    driver_args: str = arg_call(token, add_retval=False)

    return f'{retval_assignment}{function_prefix}{token.name}{driver_args};'

def mako_write(inpath: str | Path, outpath: str | Path, **kwargs) -> int:
    """Render a Mako template into a file."""
    # Objects used by all (or almost all) Mako templates.
    common_objects = {
        'FuncType': FuncType,
        'FuncLevel': FuncLevel,
        'Token': Token,
        'Argument': Argument,
        'ReturnValue': ReturnValue,
        'VkStruct': VkStruct,
        'Field': Field,
        'VkEnum': VkEnum,
        'Enumerator': Enumerator,
        'AUTO_GENERATED_HEADER': AUTO_GENERATED_HEADER,
    }

    inpath = Path(inpath)
    outpath = Path(outpath)

    try:
        print(f"Generating {outpath}...")
        template = mako.template.Template(filename=str(inpath))
        rendered = template.render(**(common_objects | kwargs))
        rendered = re.sub(r'\r\n', r'\n', rendered)

        destination = Path('..') / outpath
        with destination.open(mode='w') as fout:
            fout.write(rendered)
    except Exception:
        traceback = mako.exceptions.RichTraceback()
        for filename, lineno, function, line in traceback.traceback:
            print(f"{filename}({lineno}) : error in {function}")
            print(line, "\n")
        print(f"{traceback.error.__class__.__name__}: {traceback.error}")
        return -1
    return 0

def update_gl_ids(
    source: str | Path,
    destination_subpath: str | Path,
    gl_functions: dict[str, list[Token]]
) -> None:
    """
    Append new IDs (if any) to an ID file.

    Parameters:
        source: Path to the Mako template file.
        destination_subpath: Path to copy the file to; relative to `OpenGL/`.
        gl_functions: Dict of Tokens to generate IDs from.
    """
    source = Path(source)
    destination_subpath = Path(destination_subpath)

    gl_ids: set[str] = set()
    with source.open(mode='r') as gl_ids_file:
        for line in gl_ids_file:
            if line.startswith('ID'):
                gl_id = line.strip(',\n')
                gl_ids.add(gl_id)

    new_ids = ''
    for token_versions in gl_functions.values():
        for token in token_versions:
            gl_id = make_id(token.name, token.version)
            if gl_id not in gl_ids:
                new_ids += gl_id + ',\n'

    if not new_ids:
        print(f"File {source} is up to date.")
    else:
        print(f"Adding new IDs to {source} ...")
        with source.open(mode='a') as gl_ids_file:
            gl_ids_file.write(new_ids)

    destination = Path('..') / destination_subpath
    print(f"Copying {source} to {destination_subpath} ...")
    shutil.copy2(source, destination)


def main() -> None:
    """Generate all the files."""
    # all_tokens: list[Token] = get_functions()
    # enabled_tokens: list[Token] = [f for f in all_tokens if f.enabled]

    # update_gl_ids('glIDs.h', 'common/include', gl_functions=enabled_tokens)

    vulkan_layer_bin_path: str = ''
    match platform.system():
        case 'Windows':
            vulkan_layer_bin_path = '.\\\\VkLayer_vulkan_GITS_recorder.dll'
        case 'Linux':
            vulkan_layer_bin_path = './libVkLayer_vulkan_GITS_recorder.so'
        case other_system:
            raise NotImplementedError(
                f"Path to Vulkan layer dynamic library is unknown for system '{other_system}'.")
    mako_write(
        'templates/VkLayer_vulkan_GITS_recorder.json.mako',
        'layer/VkLayer_vulkan_GITS_recorder.json',
        vulkan_layer_bin_path=vulkan_layer_bin_path,
    )

if __name__ == '__main__':
    main()
