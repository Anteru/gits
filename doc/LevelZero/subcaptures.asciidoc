// ===================== begin_copyright_notice ============================
//
// Copyright (C) 2023-2024 Intel Corporation
//
// SPDX-License-Identifier: MIT
//
// ===================== end_copyright_notice ==============================

= Level Zero Subcaptures

:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

:language: {basebackend@docbook:c++:cpp}

== Notice

Copyright (c) 2023 Intel Corporation.

== Overview
Subcapture is a GITS stream that contains selected subset of API calls.
It preserves application functionality (input and output data is the same) but reduces its scope.
Feature supports complicated scenarios when kernel is being used multiple times inside one or more command list or kernel is reusing the same region of USM allocation.
When playing the subcapture trace back, GITS will initialize all buffers used by a kernel to the state they were during recording the application.

Level Zero is working on Command Queues and Command Lists.
Kernels are appended into a Command List and lists into a Command Queue.
GITS during recording can't determine how many kernels there will be inside a command list.
As a result, an additional pre-numbering logic is required.

Subcapture not always contain all of the application's API calls.
The goal is to select minimal portion of the application behavior.

== Activating subcapture mode
Level Zero GITS subcapture mode is activated by changing the `gits_config.txt` file, `LevelZero` section.
`LevelZero.Capture.Mode` must be set to `Kernel` and desired kernel range must be chosen: `LevelZero.Kernel.Range`.

== Nomenclature
The main nomenclature is `CommandQueueSubmitRange/CommandListRange/AppendKernelsRange`.

`CommandQueueSubmitRange` - Range of command queue executions. Every `zeCommandQueueExecuteCommandLists` API call GITS increments the value.`*`

`CommandListRange`- On every `zeCommandListCreate` or `zeCommandListCreateImmediate` API call GITS increments the value.`*`

`AppendKernelsRange` - On every family of append kernel to command list i.e.
`zeCommandListAppendLaunchKernel,
zeCommandListAppendLaunchCooperativeKernel,
zeCommandListAppendLaunchKernelIndirect,
zeCommandListAppendLaunchMultipleKernelsIndirect` GITS increments the value

`*` In case of Immediate Command Lists, on `zeCommandListCreateImmediate` API call GITS reserve(increment) the number of CommandQueueSubmitRange as well as CommandListRange.

Example of specifying kernel range `LevelZero.Capture.Kernel` to the `1/3/4-5`.
That means the first API call of `zeCommandQueueExecuteCommandList` contain third application created command list, which contains kernels, which were appended from fourth and fifth append launch kernel API for example:  `zeCommandListAppendLaunchKernel`.
The numbering logic can be looked up inside the recording log on every kernel execution.
`Basic.LogLevel` must be set to at least `TRACE`.
Recommended solution is to verify the numbering with a recorder's log after whole application was successfully recorded.

== Numbering examples
=== Example 1:

[source, c++]
----
// CommandQueueSubmit = 0; CommandList = 0; AppendKernels = 0;
zeCommandListCreate(cmd_list_1); // CommandList++ (1)
zeCommandListCreate(cmd_list_2); // CommandList++ (2)
zeCommandListCreate(cmd_list_3); // CommandList++ (3)
zeCommandListAppendLaunchKernel(cmd_list_2, kernel_1); // AppendKernels++ (1)
zeCommandListAppendLaunchKernel(cmd_list_2, kernel_2); // AppendKernels++ (2)
zeCreateCommandQueue(cmd_queue_1);
zeCommandQueueExecuteCommandLists(cmd_queue_1, {cmd_list_2}); // CommandQueueSubmit++ (1)
----
Subcapture creation of the first execution of kernel_2:

`LevelZero.Capture.Kernel         1/2/2`


=== Example 2:

[source, c++]
----
// CommandQueueSubmit = 0; CommandList = 0; AppendKernels = 0;
zeCommandListCreate(cmd_list_1); // CommandList++ (1)
zeCommandListCreate(cmd_list_2); // CommandList++ (2)
zeCommandListCreate(cmd_list_3); // CommandList++ (3)
zeCommandListAppendLaunchKernel(cmd_list_2, kernel_1); // AppendKernels++ (1)
zeCommandListAppendLaunchKernel(cmd_list_2, kernel_2); // AppendKernels++ (2)
zeCommandListCreateImmediate(cmd_list_4); // CommandList++, CommandQueueSubmit++ (4), (1)
zeCreateCommandQueue(cmd_queue_1);
zeCommandQueueExecuteCommandLists(cmd_queue_1, {cmd_list_2}); //CommandQueueSubmit++ (2)
zeCommandListAppendLaunchKernel(cmd_list_4, kernel_1); // AppendKernels++ (3)
zeCommandListAppendLaunchMultipleKernelsIndirect(cmd_list_4, {kernel_3, kernel_4}); //
// AppendKernels++, AppendKernels++ (4), (5) (the numbering of multiple kernels is the same order that they were listed)
zeCommandListAppendLaunchKernelIndirect(cmd_list_4, kernel_3); // AppendKernels++ (6)
----
To create a subcapture of the second execution of kernel_3 inside the cmd_list_4(immediate):

`LevelZero.Capture.Kernel         1/4/6`

To create a subcapture of multiple kernels range of kernels i.e. the first execution of kernel_2 and the first execution of two indirect kernels i.e. kernel_3 and kernel_4 inside cmd_list_4(immediate). That is possible by:

`LevelZero.Capture.Kernel         2,1/3,4/2,4-5`

== Recording subcapture by kernel name and execution number
TBD